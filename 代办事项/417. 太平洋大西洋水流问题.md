给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

 

提示：

输出坐标的顺序不重要
m 和 n 都小于150


示例：

 

给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).

```cpp
// bfs
class Solution
{
    int dirx[4] = {0, 0, -1, 1};
    int diry[4] = {1, -1, 0, 0};
    struct element { int x, y; };
    int n, m;
    bool mark[160][160];
    inline bool bfs(element beg, string des, vector<vector<int>>& matrix)
    {
        queue<element> q;
        memset(mark, 0, sizeof(mark));
        q.push(beg);
        mark[beg.x][beg.y] = true;
        while(!q.empty())
        {
            element cur = q.front();
            q.pop();
            for(int i = 0; i < 4; ++ i)
            {
                int nx = cur.x + dirx[i], ny = cur.y + diry[i];
                if(nx < 0 || nx >= n || ny < 0 || ny >= m) // 越界（真越界/到达目的地）
                {
                    if(des == "tpy" && (nx < 0 || ny < 0)) return true;
                    if(des == "dxy" && (nx >= n || ny >= m)) return true;
                    continue;
                }
                if(mark[nx][ny] == false && matrix[nx][ny] <= matrix[cur.x][cur.y])
                {
                    q.push({nx, ny});
                    mark[nx][ny] = true;
                }
            }
        }
        return false;
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix)
    {
        vector<vector<int>> res;
        n = matrix.size();
        if(n == 0) return res;
        m = matrix[0].size();
        vector<int> temp;
        for(int i = 0; i < n; ++ i)
        {
            for(int j = 0; j < m; ++ j)
            {
                if(bfs({i, j}, "tpy", matrix) && bfs({i, j}, "dxy", matrix))
                {
                    temp.clear();
                    temp.push_back(i);
                    temp.push_back(j);
                    res.push_back(temp);
                }
            }
        }
        return res;
    }
};
// DFS
class Solution
{
    int dirx[4] = {0, 0, -1, 1};
    int diry[4] = {1, -1, 0, 0};
    struct element { int x, y; };
    int n, m;
    bool mark[160][160];
    bool dfs(element cur, string des, vector<vector<int>>& matrix)
    {
        for(int i = 0; i < 4; ++ i)
        {
            int nx = cur.x + dirx[i], ny = cur.y + diry[i];
            if(nx < 0 || nx >= n || ny < 0 || ny >= m)
            {
                if(des == "tpy" && (nx < 0 || ny < 0)) return true;
                if(des == "dxy" && (nx >= n || ny >= m)) return true;
                continue; // 越界
            }
            if(mark[nx][ny] == false && matrix[nx][ny] <= matrix[cur.x][cur.y])
            {
                mark[nx][ny] = true;
                if(dfs({nx, ny}, des, matrix) == true) return true;
                mark[nx][ny] = false;
            }
        }
        return false;
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix)
    {
        vector<vector<int>> res;
        n = matrix.size();
        if(n == 0) return res;
        m = matrix[0].size();
        vector<int> temp;
        for(int i = 0; i < n; ++ i)
        {
            for(int j = 0; j < m; ++ j)
            {
                memset(mark, 0, sizeof(mark));
                mark[i][j] = true;
                if(dfs({i, j}, "tpy", matrix) == true)
                {
                    memset(mark, 0, sizeof(mark));
                    mark[i][j] = true;
                    if(dfs({i, j}, "dxy", matrix) == true)
                    {
                        temp.clear();
                        temp.push_back(i);
                        temp.push_back(j);
                        res.push_back(temp);
                    }
                }
            }
        }
        return res;
    }
};
```



