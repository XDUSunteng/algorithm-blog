# 知识点汇总

## 基本算法

### 实现——`unique`函数

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int>::iterator unique(vector<int> &a)
{
    int j = 0;
    for(int i = 0; i < a.size(); ++ i)
        if(i == 0 || a[i] != a[i - 1])
            a[j ++] = a[i];
    return a.begin() + j;// a[0] ~ a[j - 1]不重复
}
int main()
{
    vector<int> a = {1,2,2,3,3,3};
    a.erase(unique(a), a.end());
    for(auto e : a)
        cout << e << endl;
    return 0;
}
```

### 双指针

​    双指针问题是对于普通问题的一种特殊解法,往往要求问题是线性的,可以用双指针来遍历,从许多解中找到一个最大或者最小的解,双指针一般可以分别放在首尾处,用来往中间靠拢,或者都放在头部,用来划分区间.

### 贪心常用的证明手段

#### 微扰(邻项交换)

​    证明在任意局面下,任何对局部最优策略的微小改变都会造成整体结果变差,**经常用于以"排序"为贪心策略的证明**.

#### 范围缩放

​    证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差.

#### 决策包容性

​    证明在任意局面下,作出局部最优决策以后,在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合.换言之,这个局部最优策略提供的可能性包含其他所有策略提供的可能性.

#### 反证法

#### 数学归纳法

#### 由不等式证明等式

若`贪心得到的答案≥最优解`且`贪心得到的答案≤最优解`,则`贪心得到的答案=最优解`

### 排序不等式

正序和$\ge$乱序和$\ge$反序和.

## 常见的剪枝方法

### 优化搜索顺序

​    在一些搜索问题中,搜索树的各个层次、各个分支之间的顺序不是固定的.不同的搜索顺序会产生不同的搜索树形态,其规模大小也相差甚远.

### 排除等效冗余

​    在搜索过程中,如果我们能够判定从搜索树的当前结点上沿着某几条不同分支到达的子树是等效的,那么只需要对其中的一条分支执行搜索.

### 可行性剪枝

在搜索过程中,及时对当前状态进行检查,如果发现分支已经无法到达递归边界,就执行回溯.这就好比我们在道路上行走时,远远看到前方是一个死胡同,就应该立即折返绕路,而不是走到路的尽头再返回.

某些题目条件的范围限制是一个区间,此时可行性剪枝也被称为"上下界剪枝".

### 最优性剪枝

​    在最优化问题的搜索过程中,如果当前花费的代价已经超过了当前搜到的最优解,那么无论采取多么优秀的策略到达递归边界,都不可能更新答案.此时可以停止对当前分支的搜索,执行回溯.

### 记忆化

可以记录每个状态的搜索结果,在重复遍历一个状态时直接检索并返回.这就好比我们对图进行深度优先遍历时,标记一个顶点是否已经被访问过.

如果搜索算法遍历的状态空间是"树"形(不会重复访问),就不需要进行记录.

## 数学

### 约数个数公式

$n = p_1^{e_1}\times p_2^{e_2}\times ...\times p_k^{e_k}$.

$(e_1+1)\times (e_2 + 1) \times ... \times (e_k+1)$.

### 约数之和公式

$n = p_1^{e_1}\times p_2^{e_2}\times ...\times p_k^{e_k}$.

$(p_1^0+p_1^1+...+p_1^{e_1})\times (p_2^0+p_2^1+...+p_2^{e_2}) \times ... \times (p_k^0+p_k^1+...+p_k^{e_k})$.

### 欧拉定理

        若正整数`a, n`互质,则$a^{\phi(n)} \equiv 1 (\% n)$,其中$\phi(n)$为欧拉函数.

### 欧拉函数

$n = p_1^{e_1}\times p_2^{e_2}\times ...\times p_k^{e_k}$.

$\phi(n) = n \times \mathop \prod \limits_{i=1}^k (1 -\frac{1}{p_i})$.

### 证明

1. 算数基本定理
2. `a = kb + r`

## 动态规划

### 闫氏dp分析法

![](/img/0009.jpeg)

### 集合划分

"**最后**"二字

## 时间复杂度

### n ≤ 30​

1. `dfs`+剪枝
2. 状压`dp`

### n ≤ 100

时间复杂度$O(n^3)$.

1. `floyd`
2. `dp`
3. 高斯消元

### n ≤ 1000

时间复杂度$O(n^2)$以及$O(n^2logn)$.

1. `dp`
2. 二分

### n ≤ 10000

时间复杂度$O(n\sqrt{n})$.

1. 块状链表

### n ≤ 100000

时间复杂度$O(nlogn)$.

1. 快速排序、归并排序或堆排序
2. 线段树
3. 树状数组
4. `set`或`map`
5. 堆
6. 堆优化`dijkstra`
7. `spfa`
8. 二分

### n ≤ 1000000

时间复杂度$O(n)$以及常数较小的$O(nlogn)$.

1. 哈希
2. 双指针
3. `kmp`
4. `AC`自动机
5. 快速排序、归并排序或堆排序
6. 树状数组
7. 堆
8. 堆优化`dijkstra`
9. `spfa`

### n ≤ 10000000

时间复杂度$O(n)$.

1. 双指针
2. `kmp`
3. `AC`自动机
4. 线性筛

### n ≤ 10^9

时间复杂度$O(\sqrt{n})$.

1. 判断质数

### n ≤ 10^{18}

时间复杂度$O(logn)$.

1. 最大公约数