# 单调栈

[AcWing-830-单调栈](https://www.acwing.com/solution/AcWing/content/3481/)

## 应用

求每个数左(或右)边离它最近的比它大(或小)的数.

## 分析

单调栈名字中的单调一词,指的是栈内的元素是单调的

下面演示将序列中的元素加入单调栈的过程

```
序列:[3,1,6,4,5,2]
加入:3,栈[3]
加入:1,栈[1](弹出3)
加入:6,栈[1,6]
加入:4,栈[1,4](弹出6)
加入:5,栈[1,4,5]
加入:2,栈[1,2](弹出4和5)
```

功能:**找出序列中某元素的两边第一个比它大或小的元素的位置**

由上例,在加入1之前,需要将3弹出以维护栈的单调性,可以说**1将3弹出,3被1弹出**,而1是3的右边第一个比它小的元素.在加入2之前,需要将4和5弹出,2是4的右边第一个比它小的元素,2同时也是5的右边第一个比它小的元素.最后栈内剩下的元素的性质怎样就不用我说了8

**扩展:** 元素被(其右边的元素)弹出视作元素向右扩展结束

如何计算向左最多能扩展到的位置呢?

1. 再维护一个单调栈,反向做
2. 观察得, 加入1后,1的左边没有元素,这说明1的左边没有比它小的元素;加入4后,4左边的元素为1,这说明4左边第一个比它小的元素是1

更一般地,设栈顶元素为`top`,待入栈的元素为`num`

在序列中,`top`一定是`num`的前一个元素,因为**如果元素要入栈,那么它必能入栈**

- 如果`top < num`,将`num`入栈,同时说明`num`无法向左扩展
- 如果`top > num`,则`num`之前至少有一个元素(至少有`top`)不能扩展到`num`,因为它们必`num`大

示意图如下:

![](/img/0007.bmp)

## 实现

### 朴素算法及其优化思路

```cpp
for(int i = 1; i <= n; ++ i)
{
    bool flag = false;
    for(int j = i - 1; j >= 1; -- j)
    {
        if(a[j] < a[i])
        {
            printf("%d ", a[j]);
            flag = true;
            break;
        }
    }
    if(flag == false) printf("-1 ");
}
```

![](/img/0006.bmp)

由于`a[x1]`的存在,`a[x2]`不可能成为第`x1 + 1 ~ n`轮循环中的答案.

### 单调栈优化

```cpp
#include <iostream>
#include <stack>
using namespace std;
stack<int> stk;
int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 1, x; i <= n; ++ i)
    {
        scanf("%d", &x);
        while(!stk.empty() && stk.top() >= x) stk.pop();
        if(!stk.empty())
            printf("%d ", stk.top());
        else
            printf("-1 ");
        stk.push(x);
    }
    return 0;
}
```

