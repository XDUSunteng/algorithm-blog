# 权值线段树合并

[洛谷-P4556-[Vani有约会]雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)

## 分析

在线段树合并时,需要**动态开点**.

线段树合并的示意图如下:

![0023](/img/0023.png)

具体的流程见例题.

线段树合并的应用:处理其他数据结构难以处理的**子树问题**.

如果有若干棵线段树,它们都维护相同的值域`[1, n]`,那么它们**对各个子区间的划分是一致的**.

假设有`m`次单点修改操作,每次操作在某一棵线段树上执行.所有的操作完成后,我们希望把这些线段树对应位置上的值相加,同时维护区间最大值.

合并两棵线段树时,用两个指针`p, q`从两个根结点出发,以递归的方式**同步遍历**两棵线段树.换句话说,`p, q`指向的结点总是代表相同的子区间.

1. 若`p, q`之一为空,则以非空的那个作为合并后的结点
2. 若`p, q`均不为空,则递归合并两棵左子树和两棵右子树,然后删除结点`q`,以`p`为合并后的结点,自底向上更新最值信息.若已到达叶子结点,则直接把两个最值相加即可.

一棵维护值域`[1, n]`的动态开点的线段树在经历`m`次单点操作后,结点数量的规模为$O(mlogn)$,最终至多有`2n - 1`个结点.

仔细观察可以发现,若线段树合并过程中发生递归,则必定会导致`p, q`之一被删除.因此,在完成所有线段树的合并后,`merge`函数被执行的次数不会超过所有线段树的结点总数加一.故整个合并过程的时间复杂度为$O(mlogn)$,与完成所有单点修改的时间复杂度相等,是一个很高效的过程.

## 实现

```cpp

```

