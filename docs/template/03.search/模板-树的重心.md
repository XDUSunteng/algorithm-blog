# 树的重心

## 分析

树的重心:最大子树最小

**性质:**

1. 树中所有结点到某一个结点的距离和中,到重心的距离和是最小的.如果有两个重心,则到它们的距离和相同
2. 把两棵树通过某一点相连得到一棵新的树,新的树的重心必然在连接原来两棵树重心的路径上
3. 一棵树添加或删除一个结点,树的重心最多只移动一条边的位置

## 实现

```cpp
#include <iostream>
#include <cstring>
#define inf 0x3f3f3f3f
#define size SiZe
using namespace std;
const int N = 16010;
struct edge
{
    int next;
    int to;
};
edge e[2 * N];
int idx, head[N];

int n;
int dp[N], size[N];
void add_edge(int u, int v)
{
    e[idx].to = v;
    e[idx].next = head[u];
    head[u] = idx ++;
}
void dfs(int cur, int father)
{
    size[cur] = 1;
    for(int i = head[cur]; i != -1; i = e[i].next)
    {
        int to = e[i].to;
        if(to != father)// "向下"
        {
            dfs(to, cur);
            size[cur] += size[to];
            dp[cur] = max(dp[cur], size[to]);// 最大值
        }
    }
    dp[cur] = max(dp[cur], n - size[cur]);// 非子树的部分
}
int main()
{
    memset(head, -1, sizeof(head));
    scanf("%d", &n);
    for(int i = 1, u, v; i <= n - 1; ++ i)
    {
        scanf("%d%d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }
    dfs(1, -1);
    int minSize = inf;
    for(int i = 1; i <= n; ++ i) minSize = min(minSize, dp[i]);
    int cnt = 0;
    for(int i = 1; i <= n; ++ i)
        if(dp[i] == minSize)
            ++ cnt;
    printf("%d %d\n", minSize, cnt);
    for(int i = 1; i <= n; ++ i)
        if(dp[i] == minSize)
            printf("%d ", i);
    return 0;
}
```

