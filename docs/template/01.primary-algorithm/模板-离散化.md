# 离散化

[AcWing-802-区间和](https://www.acwing.com/solution/AcWing/content/2371/)

## 分析

​        在很多情况下,问题的范围虽然定义在整数集合`Z`,但是只涉及其中的`m`个数值,并且**与数值的绝对大小无关,只与相对大小有关**.这时,我们就可以把`Z`中的`m`个数值与数字`1 ~ m`建立映射关系.如果有一个时间复杂度、空间复杂度与数值的范围大小有关的算法,在离散化后,该算法的时间复杂度、空间复杂度就降低为与`m`相关.

## 实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<int, int> PII;
const int N = 300010;
int a, b, nums[N];
int arr[N], sum[N];
vector<PII> add, qry;
void discrete()
{
    sort(nums + 1, nums + a + 1);
    b = unique(nums + 1, nums + a + 1) - (nums + 1);// 去重, end - begin
}
int query(int x) { return lower_bound(nums + 1, nums + b + 1, x) - nums; }
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1, x, val; i <= n; ++ i)
    {
        scanf("%d%d", &x, &val);
        add.push_back({x, val});
        nums[++ a] = x;
    }
    for(int i = 1, l, r; i <= m; ++ i)
    {
        scanf("%d%d", &l, &r);
        qry.push_back({l, r});
        nums[++ a] = l, nums[++ a] = r;
    }
    discrete();
    for(auto e : add)
        arr[query(e.first)] += e.second;
    for(int i = 1; i <= b; ++ i)
        sum[i] = sum[i - 1] + arr[i];
    for(auto e : qry)
    {
        int l = query(e.first), r = query(e.second);
        printf("%d\n", sum[r] - sum[l - 1]);
    }
    return 0;
}
```

